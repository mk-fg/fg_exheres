# Copyright 2011 Mike Kazantsev
# Copyright 2008 Santiago M. Mola
# Copyright 2008, 2009, 2010, 2011 Ingmar Vanhassel
# Distributed under the terms of the GNU General Public License v2
# Based in part upon 'ghc-6.8.2.ebuild' from Gentoo, which is:
#     Copyright 1999-2008 Gentoo Foundation

require flag-o-matic multilib alternatives

SUMMARY="The Glorious Glasgow Haskell Compilation System"
DESCRIPTION="
GHC is a state-of-the-art, open source, compiler and interactive environment for the functional language Haskell.
"

HOMEPAGE="http://www.haskell.org/ghc/"
DOWNLOADS="http://haskell.org/ghc/dist/${PV}/${PNV}-src.tar.bz2"

LICENCES="BSD-3"
SLOT="${PV}"
PLATFORMS="~amd64 ~x86"
MYOPTIONS="
    bootstrap doc
    platform:
        amd64
        x86
"

DEPENDENCIES="
    build:
        app-text/docbook-xml-dtd:4.2
        app-text/docbook-xsl-stylesheets
        dev-libs/libxslt[>=1.1.2]
        doc? (
                !bootstrap? ( dev-haskell/haddock[>=0.8] )
        )
        bootstrap? ( || (
            dev-lang/ghc
            dev-lang/ghc-bin ) )
    build+run:
        dev-lang/perl
        dev-libs/gmp
        sys-libs/ncurses
"

BUGS_TO="mk.fraggod@gmail.com"
REMOTE_IDS="freshmeat:${PN}"
UPSTREAM_RELEASE_NOTES="http://www.haskell.org/${PN}/docs/${PV}/html/users_guide/release-${PV//./-}.html"


append-ghc-cflags() {
    local flag compile assemble link
    for flag in ${@}; do
        case ${flag} in
            compile)  compile="yes" ;;
            assemble) assemble="yes" ;;
            link)	 link="yes" ;;
            *) [[ -n ${compile}  ]] && GHC_CFLAGS="${GHC_CFLAGS} -optc${flag}"
                [[ -n ${assemble} ]] && GHC_CFLAGS="${GHC_CFLAGS} -opta${flag}"
                [[ -n ${link}	 ]] && GHC_CFLAGS="${GHC_CFLAGS} -optl${flag}" ;;
        esac
    done
}

ghc_setup_cflags() {
    # We need to be very careful with the CFLAGS we ask ghc to pass through to gcc.
    # There are plenty of flags which will make gcc produce output that breaks ghc in various ways.
    # The main ones we want to pass through are -mcpu / -march flags.
    # These are important for arches like alpha & sparc.
    # We also use these CFLAGS for building the C parts of ghc, ie the rts.
    strip-flags
    strip-unsupported-flags
    filter-flags -fPIC

    GHC_CFLAGS=""
    for flag in ${CFLAGS}; do
        case ${flag} in
            # Arch and ABI flags are what we're really after
            -m*) append-ghc-cflags compile assemble ${flag} ;;
            # Ignore extra optimisation (ghc passes -O to gcc anyway)
            # -O2 and above break on too many systems
            -O*) : ;;
            # Debugging flags don't help either. You can't debug Haskell code
            # at the C source level and the mangler discards the debug info.
            -g*) : ;;
            # Ignore all other flags, including all -f* flags
            *)   : ;;
        esac
    done

    # We also add -Wa,--noexecstack to get ghc to generate .o files with
    # non-exectable stack. This it a hack until ghc does it itself properly.
    append-ghc-cflags assemble "-Wa,--noexecstack"
}

pkg_pretend() {
    if option !bootstrap && ! ghc --version &>/dev/null; then
        ewarn "You need GHC installed to compile GHC from source."
        ewarn "Try installing dev-lang/ghc[bootstrap]"
        die "Could not find a ghc to bootstrap with"
    fi
}

src_prepare() {
    ghc_setup_cflags

    default

    # Modify the ghc driver script to use GHC_CFLAGS
    edo sed -e "s|\$\$TOPDIROPT|\$\$TOPDIROPT ${GHC_CFLAGS}|" \
        -i "${WORK}/driver/ghc/Makefile"
}

src_configure() {
    # Initialize build.mk
    echo '# Exherbo changes' > mk/build.mk

    cat <<EOF >> mk/build.mk
# Put docs into the right place
docdir = /usr/share/doc/${PNVR}
htmldir = /usr/share/doc/${PNVR}/html

# Use GHC_CFLAGS flags when building ghc itself
SRC_HC_OPTS += ${GHC_CFLAGS}
SRC_CC_OPTS += ${CFLAGS} -Wa,--noexecstack
EOF

    if option doc; then
        echo "XMLDocWays=html" >> mk/build.mk
        echo "HADDOCK_DOCS=YES" >> mk/build.mk
    else
        echo "XMLDocWays=" >> mk/build.mk
        echo "HADDOCK_DOCS=NO" >> mk/build.mk
    fi

    econf --hates=build --hates=host "${GHC_SRC_CONFIGURE_OPTIONS[@]}"
}

ghc_bundled_util_version() {
    local ver=$(sed -ne 's/^version:[ \t]*//ip' "${WORK}"/utils/${1}/${1}.cabal)
    [[ -n ${ver} ]] || die "could not determine version of bundled ${1}"
    echo ${ver}
}

src_install() {
    default_src_install

    option !doc && edo rm -rf "${IMAGE}"/usr/share/doc/${PNVR}/html
    # libraries/ is a partial dupe of the html/ dir hierarchy, but
    # containing only LICENSE files
    edo rm -rf "${IMAGE}"/usr/share/doc/${PNVR}/{LICENSE,libraries}

    # Alternatives:
    cd "${IMAGE}" || die "Failed to enter \$IMAGE=${IMAGE}"

    # Delete symlinks that we'll replace with alternatives
    local symlink
    for symlink in ghc ghci ghc-pkg runhaskell ; do
        [[ -f usr/bin/${symlink} && -L usr/bin/${symlink} ]] ||
            die "Expected ${IMAGE}/usr/bin/${symlink} to be a symlink, but it isn't"
        edo rm usr/bin/${symlink}
    done

    # Version all executables, manual pages
    local executable manpage
    for executable in usr/bin/* ; do
        if [[ ${executable} != *-${SLOT} ]]; then
            edo mv ${executable}{,-${SLOT}}
        fi
    done
    for manpage in usr/share/man/man?/* ; do
        edo mv ${manpage} ${manpage%%.1}-${SLOT}.1
    done

    # Record alternatives
    local alternatives=() src target

    for src in usr/bin/*-${SLOT} usr/share/man/man?/*-${SLOT}.? ; do
        if [[ ${src} == usr/bin/haddock-${SLOT} ]]; then
            edo mv "${IMAGE}/${src}" "${IMAGE}/usr/bin/haddock-ghc-${SLOT}"
            local haddock_pv=$(ghc_bundled_util_version haddock)
            alternatives_for haddock ${haddock_pv}_ghc-${SLOT} ${haddock_pv} /usr/bin/haddock /usr/bin/haddock-ghc-${SLOT}
        elif [[ ${src} == usr/bin/hsc2hs-${SLOT} ]]; then
            edo mv "${IMAGE}/${src}" "${IMAGE}/usr/bin/hsc2hs-ghc-${SLOT}"
            local hsc2hs_pv=$(ghc_bundled_util_version hsc2hs)
            alternatives_for hsc2hs ${hsc2hs_pv}_ghc-${SLOT} ${hsc2hs_pv} /usr/bin/hsc2hs /usr/bin/hsc2hs-ghc-${SLOT}
        else
            target=${src/-${SLOT}}
            src=${src##*/}
            alternatives+=( "/${target}" "${src}" )
        fi
    done

    alternatives_for ${PN} ${SLOT} ${SLOT} \
        "${alternatives[@]}" \
        /usr/bin/runhaskell /usr/bin/runghc-${SLOT}

    edo sed -e "s,/usr/bin/ghc,/usr/bin/ghc-${SLOT}," \
            -i "${IMAGE}"/usr/bin/runghc-${SLOT}

    # Used in ghc_pkg_prerm(), to unmerge ourselves cleanly
    if [[ -d ${IMAGE}/usr/$(get_libdir)/${PNV}/package.conf.d ]] ; then
        insinto /usr/$(get_libdir)/${PNV}/package.conf.d.shipped/
        doins -r "${IMAGE}"/usr/$(get_libdir)/${PNV}/package.conf.d/*
    fi
    if [[ -f ${IMAGE}/usr/$(get_libdir)/${PNV}/package.conf ]] ; then
        edo cp -p "${IMAGE}/usr/$(get_libdir)/${PNV}/package.conf"{,.shipped}
    fi
}

pkg_prerm() {
    alternatives_pkg_prerm

    # Overwrite the (potentially) modified package.conf with a copy of the
    # original one, so that it will be removed during uninstall.
    # Code below can go once we drop ghc[<6.12.1]

    PKG="${ROOT}/usr/$(get_libdir)/${PNV}/package.conf"

    if [[ -f ${PKG}.shipped ]] ; then
        cp -p "${PKG}"{.shipped,}
    fi

    [[ -f ${PKG}.old ]] && rm "${PKG}.old"
}

pkg_postinst() {
    alternatives_pkg_postinst
    # FIXME: ${ROOT}
    local script
    for script in /usr/$(get_libdir)/${PNV}/registration/*/register.sh ; do
        [[ -f ${script} ]] || continue
        # let's not kill the installation just for this...
        echo "sh ${script}"
        sh "${script}" || ewarn "Reregistering ${script} failed!"
    done
}
