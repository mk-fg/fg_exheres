Source: Mike Kazantsev (MK_FG on IRC)
Upstream:
  no, although different solution (not upstream either)
  is available here: http://www.fossil-scm.org/index.html/tktview?name=727af73f46
Reason:
  If openssl validates certificate as invalid (not just untrusted),
  fossil is able to store it, but subsequent validation will fail as well,
  forcing a user to interactively accept it on each sync.
  The patch removes validation code for good, so no trust or validity checks are
  made and no supid questions asked, thus nullifying https security against
  MiTM attacks (but not passive sniffing), at least making https usage tolerable.

diff --git a/src/http_ssl.c b/src/http_ssl.c
index fd87469..5114ff2 100644
--- a/src/http_ssl.c
+++ b/src/http_ssl.c
@@ -178,40 +178,6 @@ char *connStr ;
     return 1;
   }
 
-  if( SSL_get_verify_result(ssl) != X509_V_OK ){
-    char *desc, *prompt;
-    char *warning = "";
-    Blob ans;
-    BIO *mem;
-    
-    mem = BIO_new(BIO_s_mem());
-    X509_NAME_print_ex(mem, X509_get_subject_name(cert), 2, XN_FLAG_MULTILINE);
-    BIO_puts(mem, "\n\nIssued By:\n\n");
-    X509_NAME_print_ex(mem, X509_get_issuer_name(cert), 2, XN_FLAG_MULTILINE);
-    BIO_write(mem, "", 1); // null-terminate mem buffer
-    BIO_get_mem_data(mem, &desc);
-    
-    if( hasSavedCertificate ){
-      warning = "WARNING: Certificate doesn't match the "
-                "saved certificate for this host!";
-    }
-    prompt = mprintf("\nUnknown SSL certificate:\n\n%s\n\n%s\n"
-                     "Accept certificate [a=always/y/N]? ", desc, warning);
-    BIO_free(mem);
-
-    prompt_user(prompt, &ans);
-    free(prompt);
-    if( blob_str(&ans)[0]!='y' && blob_str(&ans)[0]!='a' ) {
-      X509_free(cert);
-      ssl_set_errmsg("SSL certificate declined");
-      ssl_close();
-      return 1;
-    }
-    if( blob_str(&ans)[0]=='a' ) {
-      ssl_save_certificate(cert);
-    }
-    blob_reset(&ans);
-  }
   X509_free(cert);
   return 0;
 }
